syntax = "proto3";

option java_package = "com.moonsworth.apollo.api.protocol";
option java_outer_classname = "ApolloProtocol";
option java_multiple_files = true;

// The server mod list.
message ServerModList {
  repeated string mods = 1;
}

// The client mod settings message.
message ClientModSettings {
  message ModSettings {
    optional bool enable = 1;
    map<string, string> settings = 2;
  }

  map<string, ModSettings> mods = 1;
}

message ClearCooldownMessage {

}

message CooldownMessage {
  bytes name = 1;
  int64 durationMs = 2;
  oneof icon {
    int32 itemId = 3;
    RenderableIcon iconLocation = 4;
  }
}

message StaffMods {
  enum StaffModule {
    XRAY = 0;
  }
  StaffModule module = 1;
  bool value = 2;
}

message TeammateMessage {
  repeated Teammate teammates = 1;
}

message Teammate {
  bytes player = 1;
  int32 color = 2;
  // Coordinates are only used when the player is out of render distance for the observer
  // If you know the players are close you choose not to send these values.
  bytes world = 3;
  sint32 x = 4;
  sint32 y = 5;
  sint32 z = 6;
}

message HeartTextureMessage {
  /**
  Set to -1 to Remove

  This xLocation is the location of the start of the x coordinate in the icons.png for your extra hearts
  You can extend that image as much as needed, but keep in mind you will need to have a 1/2 heart and damage taken variation of every heart
  This xLocation will be calculated as follows: startOfImage + (xLocation * 2 + healing) * 9
  startOfImage = 16
  healing is either 0 (no healing), 1 (absorption), 2 (healing), or 3 (healing & absorption)
  I am not entirely sure how absorption will work for tons of extra textures, so keep that in mind.

  You have the option to set hearts to render as hardcore, these hardcore hearts must be in line to to other hardcore hearts
  If you have a few custom models and are not using the hardcore hearts I would recommend evenly distributing them between regular and hardcore hearts

  For example: Poison hearts have an xLocation of 4, Wither hearts have an xLocation of 7
   */
  int32 xLocation = 1; // Set to -1 to remove
  bool hardCore = 2;
}

message ColoredFireMessage {
  map<string, int32> playerFireColor = 1;
}

message NotificationMessage {
  bytes title = 1;
  bytes description = 2;
  bytes resourceLocation = 3;
}

message NametagMessage {
  bytes playerAffected = 1;
  bool hideNametag = 2;
  repeated RenderableString nametagOverride = 3;
  int32 indexContainingPlayerName = 4;
}

message AddWaypointMessage {
  Waypoint waypoint = 1;
  sint32 color = 2;
  sint32 x = 3;
  sint32 y = 4;
  sint32 z = 5;
  bool forced = 6;
  bool visible = 7;
}

message RemoveWaypointMessage {
  Waypoint waypoint = 1;
}

message Waypoint {
  bytes name = 1;
  bytes world = 2;
}

// Only supported or needed for 1.7.10.
// Please use the normal minecraft API for all other versions.
message TitleMessage {
  bytes message = 1;
  float scale = 2;
  int64 displayTimeMs = 3;
  int64 fadeInTimeMs = 4;
  int64 fadeOutTimeMs = 5;
  bool title = 6;
}

// Only supported or needed for 1.7.10.
// Please use the normal minecraft API for all other versions.
// Ideally you would integrate this into your spigot so that you can use
// a singular API for all of these components.
message CreateUpdateWorldBorderMessage {
  bytes id = 1;
  bytes world = 2;
  bool cancelEntry = 3;
  bool cancelExit = 4;
  bool canShrinkOrExpand = 5;
  sint32 color = 6;
  double minX = 7;
  double minZ = 8;
  double maxX = 9;
  double maxZ = 10;
  int32 durationTicks = 11;
}

message RemoveWorldBorderMessage {
  bytes id = 1;
}

message RenderableSpriteIcon {
  bytes location = 1;
  RenderableIconSpecifications specification = 2;
}

message RenderableIcon {
  bytes location = 1;
  oneof textureDetails {
    int32 size = 2;
    RenderableIconSpecifications specification = 3;
  }
}

message RenderableIconSpecifications {
  float width = 1; // Size of the image width (in pixels)
  float height = 2; // Size of the image height (in pixels)
  float uMin = 3; // A range of 0-1 (the x location on a TextureAtlas)
  float uMax = 4; // A range of 0-1 (the x location on a TextureAtlas)
  float vMin = 5; // A range of 0-1 (the y location on a TextureAtlas)
  float vMax = 6; // A range of 0-1 (the y location on a TextureAtlas)
}

message RenderableString {
  enum TextDecorators {
    OBFUSCATED = 0;
    BOLD = 1;
    STRIKETHROUGH = 2;
    UNDERLINED = 3;
    ITALIC = 4;
  }
  bytes content = 1;
  sint32 color = 2;
  repeated TextDecorators decoration = 3;
  repeated RenderableString children = 4;
}

message ToggleArmorMessage {
  bool showArmor = 1;
}

message OpenGuiMessage {
  enum Gui {
    SUIT_GUI = 0;
    CHARACTER_SELECTION = 1;
    OBSERVER_UI = 2;
  }
  Gui guiId = 1;
  bool close = 2;
}

enum CharacterType {
  Angel = 0;
  Axel = 1;
  Banjax = 2;
  Daedra = 3;
  Froska = 4;
  Granny = 5;
  GreatMage = 6;
  Ignus = 7;
  Tulabot = 8;
}

message EventPlayerStatusMessage {
  repeated EventPlayerStatus teamOneStatus = 1;
  repeated EventPlayerStatus teamTwoStatus = 2;
}

message EventPlayerStatus {
  bytes playerId = 1; // player uuid
  float health = 2;
  float ultimatePercentage = 3;
  int64 respawnAt = 4; // A timestamp (in millis) for when the player will respawn.
}

message EventGameStatusMessage {
  EventTeamStatus teamOneStatus = 1;
  EventTeamStatus teamTwoStatus = 2;
  float tier3Health = 3;
  int64 gameStartTime = 4;
  bool witherShields = 5;
  bool lockGametime = 6;
  int64 midRespawnTime = 7; // The timestamp (in millis) for when the next mid-boss will spawn, if the health is > 0 this value is ignored.
}

message EventTeamStatus {
  float topWitherHealth = 1;
  float topCrystalHealth = 2;
  float middleWitherHealth = 3;
  float middleCrystalHealth = 4;
  float bottomWitherHealth = 5;
  float bottomCrystalHealth = 6;
  float dragonHealth = 7;
}

message ApplyCharacterCosmeticsMessage {
  bytes npcId = 1; // The UUID of the NPC
  CharacterType characterType = 2;
}

message CharacterAbilityMessage {
  repeated CharacterAbility abilities = 1;
}

message CharacterAbility {
  CharacterType type = 1;
  repeated RenderableString abilities = 2;
}

message EquipCharacterMessage {
  CharacterType id = 1;
  bool equipped = 2;
  bytes player = 3; // The UUID of the player who selected this character -- Not populated from client to server.
  int32 color = 4; // The color of the player
}

message EventPlayer {
  bytes playerId = 1;
  bytes playerName = 2;
  CharacterType characterSelected = 3;
  bool teamOne = 4; // true for team 1, false for team 2
}

message CharacterOverviewMessage {
  repeated EventPlayer players = 1;
}

/**
  Display a vignette texture on the client's screen (like a pumpkin head) with a given opacity. Use 0 opacity to hide the texture
 */
message DisplayVignetteMessage {
  repeated string texture = 1;
  float opacity = 2;
}

message BlockPosition {
  sint32 x = 1;
  sint32 y = 2;
  sint32 z = 3;
}

message DisplayBeaconMessage {
  int32 id = 1;
  int32 color = 2;
  BlockPosition position = 3;
}

message RemoveBeaconMessage {
  int32 id = 1;
}

message UUIDMessage {
  repeated string value = 1;
}

enum ArmorPart {
  Helmet = 0;
  Chestplate = 1;
  Leggings = 2;
  Boots = 3;
}

enum BodyPart {
  Head = 0;
  Torso = 1;
  LeftArm = 2;
  RightArm = 3;
  LeftLeg = 4;
  RightLeg = 5;
}

message HideArmor {
  UUIDMessage affectedPlayer = 1;
  ArmorPart armor = 2;
  bool hidden = 3;
}

message HideBodyPart {
  UUIDMessage affectedPlayer = 1;
  BodyPart bone = 2;
  bool hidden = 3;
}

message FlipAllEntitiesMessage {
  bool flipped = 1;
}

message EnableRainbowSheepMessage {
  UUIDMessage sheepEntityID = 1;
  bool rainbow = 2;
}

message Vector3DMessage {
  double x = 1;
  double y = 2;
  double z = 3;
}

message TranslateNametagMessage {
  UUIDMessage entityID = 1;
  Vector3DMessage translation = 2;
}

message UpdateCosmeticResourcesMessage {
  CharacterType character = 1;
  UUIDMessage playerID = 2;
  bytes modelPath = 3;
  bytes animationPath = 4;
  bytes texturePath = 5;
}

message ReloadCosmeticsMessage {
  repeated string modelLocations = 1;
  repeated string animationLocations = 2;
}